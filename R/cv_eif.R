#' Cross-validated evaluation of EIF components
#'
#' @param fold Object specifying cross-validation folds as generated by a call
#'  to \code{origami::make_folds}.
#' @param data ...
#' @param delta_shift ...
#' @param lrnr_stack_g ...
#' @param lrnr_stack_e ...
#' @param lrnr_stack_m ...
#'
#' @importFrom data.table data.table
#' @importFrom origami training validation fold_index
#' @importFrom stats predict as.formula glm
#' @importFrom hal9001 fit_hal
#
cv_eif <- function(fold,
                   data,
                   delta_shift,
                   lrnr_stack_g,
                   lrnr_stack_e,
                   lrnr_stack_m) {
  # make training and validation data
  train_data <- origami::training(data)
  valid_data <- origami::validation(data)

  # compute nuisance parameters eta = (g, m, e, phi)
  ## 1) fit regression for incremental propensity score intervention
  g_out <- fit_g_mech(data = train_data, valid_data = valid_data,
                      delta_shift = delta_shift,
                      lrnr_stack = lrnr_stack_g, w_names = w_names)

  ## 2) fit clever regression for treatment, conditional on mediators
  e_out <- fit_e_mech(data = train_data, valid_data = valid_data,
                      lrnr_stack = lrnr_stack_e,
                      z_names = z_names, w_names = w_names)

  ## 3) fit regression for incremental propensity score intervention
  m_out <- fit_m_mech(data = train_data, valid_data = valid_data,
                      lrnr_stack = lrnr_stack_m,
                      z_names = z_names, w_names = w_names)

  ## 4) difference-reduced dimension regression for phi
  m_pred_A1 <- m_out$m_pred$m_pred_A1
  m_pred_A0 <- m_out$m_pred$m_pred_A0
  m_pred_diff <- m_pred_A1 - m_pred_A0
  #phi_hal <- hal9001::fit_hal(X = as.matrix(valid_data[, ..w_names]),
                              #Y = as.numeric(m_pred_diff), yolo = FALSE)
  #phi_est <- stats::predict(phi_hal, new_data = valid_data)
  phi_glm <- stats::glm(stats::as.formula(paste("m_pred_diff ~",
                                                paste(w_names,
                                                      collapse = " + "))),
                         data =
                           data.table::data.table(m_pred_diff,
                                                  valid_data[, ..w_names]))
  phi_est <- as.numeric(stats::predict(phi_glm))


  # compute component Dzw from nuisance parameters
  g_shifted_A1 <- g_out$g_est$g_pred_shifted
  g_shifted_A0 <- 1 - g_shifted_A1
  Dzw <- (m_pred_A0 * g_shifted_A0) + (m_pred_A1 * g_shifted_A1)


  # compute component Da from nuisance parameters
  g_pred_A1 <- g_out$g_est$g_pred_A1
  g_pred_A0 <- g_out$g_est$g_pred_A0
  Da_numerator <- delta_shift * phi_est * (valid_data$A - g_pred_A1)
  Da_denominator <- (delta_shift * g_pred_A1 + g_pred_A0)^2
  Da <- Da_numerator / Da_denominator


  # compute component Dy from nuisance parameters
  Dy <- rep(NA, nrow(valid_data))
  idx_A1 <- which(valid_data$A == 1)
  idx_A0 <- which(valid_data$A == 0)
  g_shifted_A1_obs <- g_shifted_A1[idx_A1]
  g_shifted_A0_obs <- g_shifted_A0[idx_A0]
  e_pred_A1_obs <- e_out$e_pred[idx_A1]
  e_pred_A0_obs <- e_out$e_pred[idx_A0]
  m_pred_A1_obs <- m_pred_A1[idx_A1]
  m_pred_A0_obs <- m_pred_A0[idx_A0]
  y_A1_obs <- valid_data$Y[idx_A1]
  y_A0_obs <- valid_data$Y[idx_A0]
  Dy_A1 <- (g_shifted_A1_obs / e_pred_A1_obs) * (y_A1_obs - m_pred_A1_obs)
  Dy_A0 <- (g_shifted_A0_obs / e_pred_A0_obs) * (y_A0_obs - m_pred_A0_obs)
  Dy[idx_A1] <- Dy_A1
  Dy[idx_A0] <- Dy_A0


  # output list
  out <- list(data.table::data.table(Dy = Dy, Da = Da, Dzw = Dzw,
                                     fold = origami::fold_index()))
  return(out)
}

